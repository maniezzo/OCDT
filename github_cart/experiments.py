# -*- coding: utf-8 -*-
"""Experiments.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aVwvdSmgdA3GMcsmGcl-6acs6u0iJhLA

## Import Packages
"""

import time
from os import path

import pandas as pd
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split

import dataset
import tree as miptree
from sklearn import tree

"""## Optimal Classification Tree """

timelimit = 600
tstart = time.process_time()
"""
datasets = ['balance-scale', 'breast-cancer', 'car-evaluation', 'hayes-roth', 'house-votes-84', 
            'soybean-small', 'spect', 'tic-tac-toe', 'monks-1', 'monks-2', 'monks-3', 'nath_jones']
"""
datasets = ['monks-1']
#alpha = [0, 0.01, 0.1]
alpha = [0.01]
#depth = [2, 3, 4, 5]
depth = [5]
#seeds = [37, 42, 53]
seeds = [666]

train_ratio = 0.5
val_ratio   = 0.25
test_ratio  = 0.25

# create or load table
res_sk = pd.DataFrame(columns=['instance', 'depth', 'seed', 'train_acc', 'val_acc', 'test_acc', 'train_time'])
if path.isfile('./res/oct.csv'):
    res_oct = pd.read_csv('./res/oct.csv')
else:
    res_oct = pd.DataFrame(columns=['instance', 'depth', 'alpha', 'seed', 
                                    'train_acc', 'val_acc', 'test_acc', 'train_time', 'gap'])
if path.isfile('./res/mfoct.csv'):
    res_mfoct = pd.read_csv('./res/mfoct.csv')
else:
    res_mfoct = pd.DataFrame(columns=['instance', 'depth', 'alpha', 'seed', 
                                      'train_acc', 'val_acc', 'test_acc', 'train_time', 'gap'])
if path.isfile('./res/boct.csv'):
    res_boct = pd.read_csv('./res/boct.csv')
else:
    res_boct = pd.DataFrame(columns=['instance', 'depth', 'seed', 
                                     'train_acc', 'val_acc', 'test_acc', 'train_time', 'gap'])
if path.isfile('./res/soct.csv'):
    res_soct = pd.read_csv('./res/soct.csv')
else:
    res_soct = pd.DataFrame(columns=['instance', 'method', 'depth', 'alpha', 'seed', 
                                     'train_acc', 'val_acc', 'test_acc', 'train_time', 'gap'])

# ---------------------------------------- CART
print(" -------------------------------------------- strating CART")
for data in datasets:
    for d in depth:
        for s in seeds:
           x, y = dataset.loadData(data)
           x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=1-train_ratio, random_state=s)
           x_val, x_test, y_val, y_test = train_test_split(x_test, y_test,
                                                            test_size=test_ratio/(test_ratio+val_ratio), random_state=s)
           # this comes with sklearn
           clf = tree.DecisionTreeClassifier(max_depth=d)
           tick = time.time()
           clf.fit(x_train, y_train)
           tock = time.time()
           train_time = tock - tick
           train_acc = accuracy_score(y_train, clf.predict(x_train))
           val_acc = accuracy_score(y_val, clf.predict(x_val))
           test_acc = accuracy_score(y_test, clf.predict(x_test))
           print(data, 'cart-d{}'.format(d), 'train acc:', train_acc, 'val acc:', val_acc)
           row = {'instance':data, 'depth':d, 'seed':s, 'train_acc':train_acc,
                   'val_acc':val_acc, 'test_acc':test_acc, 'train_time':train_time}
           #res_sk = res_sk.append(row, ignore_index=True)
           res_sk.loc[len(res_sk)] = row
           res_sk.to_csv('./res/sk.csv', index=False)
           tree_rules = tree.export_text(clf) #,feature_names=list(res_sk.columns)
           print(tree_rules)
tcart = time.process_time()
print(f" -------------------------------------------- completing CART, timelimit {timelimit}, cpu {tcart - tstart}")

# ---------------------------------------- optimal classification tree
print(" -------------------------------------------- strating OCT")
for data in datasets:
    for d in depth:
        for s in seeds:
            # load data
            x, y = dataset.loadData(data)
            # onehot encoding
            x_enc = dataset.oneHot(x)
            # data splition
            x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=1-train_ratio, random_state=s)
            x_val, x_test, y_val, y_test = train_test_split(x_test, y_test, 
                                                            test_size=test_ratio/(test_ratio+val_ratio), random_state=s)
            x_train_enc, x_test_enc, y_train, y_test = train_test_split(x_enc, y, test_size=1-train_ratio, random_state=s)
            x_val_enc, x_test_enc, y_val, y_test = train_test_split(x_test_enc, y_test, 
                                                                    test_size=test_ratio/(test_ratio+val_ratio), random_state=s)
            
            for a in alpha:
                # oct
                row = res_oct[(res_oct['instance'] == data) & (res_oct['depth'] == d) & 
                              (res_oct['alpha'] == a) & (res_oct['seed'] == s)]
                if len(row):
                   print(data, 'oct-d{}-a{}'.format(row['depth'].values[0],row['alpha'].values[0]),
                          'train acc:', row['train_acc'].values[0], 'val acc:', row['val_acc'].values[0],
                          'gap:', row['gap'].values[0])
                else:
                   octree = miptree.optimalDecisionTreeClassifier(max_depth=d, min_samples_split=0, alpha=a, warmstart=False,
                                                                   timelimit=timelimit, output=False)
                   tick = time.time()
                   octree.fit(x_train, y_train)
                   tock = time.time()
                   train_time = tock - tick
                   train_acc = accuracy_score(y_train, octree.predict(x_train))
                   val_acc = accuracy_score(y_val, octree.predict(x_val))
                   test_acc = accuracy_score(y_test, octree.predict(x_test))
                   row = {'instance':data, 'depth':d, 'alpha':a, 'seed':s, 'train_acc':train_acc, 'val_acc':val_acc,
                           'test_acc':test_acc, 'train_time':train_time, 'gap':octree.optgap}
                   #res_oct = res_oct.append(row, ignore_index=True)
                   res_oct.loc[len(res_oct)] = row
                   res_oct.to_csv('./res/oct.csv', index=False)
                   print(data, 'oct-d{}-a{}'.format(d,a),
                          'train acc:', train_acc, 'val acc:', val_acc, 'gap:', octree.optgap)
                   print(row)
                   rules = octree.getRules_public(clf)

                # mfoct
                row = res_mfoct[(res_mfoct['instance'] == data) & (res_mfoct['depth'] == d) & 
                                (res_mfoct['alpha'] == a) & (res_mfoct['seed'] == s)]
                if len(row):
                    print(data, 'mfoct-d{}-a{}'.format(row['depth'].values[0],row['alpha'].values[0]),
                          'train acc:', row['train_acc'].values[0], 'val acc:', row['val_acc'].values[0],
                          'gap:', row['gap'].values[0])
                else:
                    mfoct = miptree.maxFlowOptimalDecisionTreeClassifier(max_depth=d, alpha=a, warmstart=False,
                                                                         timelimit=timelimit, output=False)
                    tick = time.time()
                    mfoct.fit(x_train_enc, y_train)
                    tock = time.time()
                    train_time = tock - tick
                    train_acc = accuracy_score(y_train, mfoct.predict(x_train_enc))
                    val_acc = accuracy_score(y_val, mfoct.predict(x_val_enc))
                    test_acc = accuracy_score(y_test, mfoct.predict(x_test_enc))
                    row = {'instance':data, 'depth':d, 'alpha':a, 'seed':s, 'train_acc':train_acc, 'val_acc':val_acc,
                           'test_acc':test_acc, 'train_time':train_time, 'gap':mfoct.optgap}
                    res_mfoct = res_mfoct._append(row, ignore_index=True)
                    res_mfoct.loc[len(res_mfoct)] = row
                    res_mfoct.to_csv('./res/mfoct.csv', index=False)
                    print(data, 'mfoct-d{}-a{}'.format(d,a), 
                          'train acc:', train_acc, 'val acc:', val_acc, 'gap:', mfoct.optgap)
                    #print(row)
            
            # boct
            row = res_boct[(res_boct['instance'] == data) & (res_boct['depth'] == d) & (res_boct['seed'] == s)]
            if len(row):
                print(data, 'boct-d{}'.format(row['depth'].values[0]),
                      'train acc:', row['train_acc'].values[0], 'val acc:', row['val_acc'].values[0], 
                      'gap:', row['gap'].values[0])
            else:
                boct = miptree.binOptimalDecisionTreeClassifier(max_depth=d, min_samples_split=0, warmstart=False,
                                                                timelimit=timelimit, output=False)
                tick = time.time()
                boct.fit(x_train, y_train)
                tock = time.time()
                train_time = tock - tick
                train_acc = accuracy_score(y_train, boct.predict(x_train))
                val_acc = accuracy_score(y_val, boct.predict(x_val))
                test_acc = accuracy_score(y_test, boct.predict(x_test))
                row = {'instance':data, 'depth':d, 'seed':s, 'train_acc':train_acc, 'val_acc':val_acc,
                       'test_acc':test_acc, 'train_time':train_time, 'gap':boct.optgap}
                #res_boct = res_boct.append(row, ignore_index=True)
                res_boct.loc[len(res_boct)] = row
                res_boct.to_csv('./res/boct.csv', index=False)
                print(data, 'boct-d{}'.format(d), 'train acc:', train_acc, 'val acc:', val_acc, 'gap:', boct.optgap)
                #print(row)
toct = time.process_time()
print(f" -------------------------------------------- completing OCT, timelimit {timelimit}, cpu {toct - tcart}")

# ---------------------------------------- Stable Optimal Classification Tree (Maxflow)
#seeds = [11, 23, 34, 45, 56, 67, 78, 89, 93, 5]
d = 3

print(" -------------------------------------------- starting SOCT")
for data in datasets:
    for s in seeds:
        
        # load data
        x, y = dataset.loadData(data)
        # onehot encoding
        x_enc = dataset.oneHot(x)
        # data splition
        x_train_enc, x_test_enc, y_train, y_test = train_test_split(x_enc, y, test_size=test_ratio, random_state=s)
        N = int(len(y_train) * train_ratio / (train_ratio + val_ratio))
        
        for a in alpha:
            # mfoct
            x_train_enc_s, x_val_enc_s, y_train_s, y_val_s = train_test_split(x_train_enc, y_train, 
                                                                              test_size=val_ratio/(train_ratio+val_ratio), 
                                                                              random_state=3)
            row = res_soct[(res_soct['instance'] == data) & (res_soct['method'] == 'n') & (res_soct['depth'] == d) &
                           (res_soct['alpha'] == a) & (res_soct['seed'] == s)]
            if len(row):
                print(data, 'mfoct-d{}-a{}'.format(row['depth'].values[0],row['alpha'].values[0]),
                      'method', row['method'].values[0], 'train acc:', row['train_acc'].values[0], 
                      'test acc:', row['test_acc'].values[0], row['gap'].values[0])
            else:
                mfoct = miptree.maxFlowOptimalDecisionTreeClassifier(max_depth=2, alpha=a, warmstart=False,
                                                                     timelimit=timelimit, output=False)
                tick = time.time()
                mfoct.fit(x_train_enc_s, y_train_s)
                tock = time.time()
                train_time = tock - tick
                train_acc = accuracy_score(y_train_s, mfoct.predict(x_train_enc_s))
                val_acc = accuracy_score(y_val_s, mfoct.predict(x_val_enc_s))
                test_acc = accuracy_score(y_test, mfoct.predict(x_test_enc))
                row = {'instance':data, 'method':'n', 'depth':d, 'alpha':a, 'seed':s, 
                       'train_acc':train_acc, 'val_acc': val_acc, 'test_acc':test_acc, 
                       'train_time':train_time, 'gap':mfoct.optgap}
                #res_soct = res_soct.append(row, ignore_index=True)
                res_soct.loc[len(res_soct)] = row
                res_soct.to_csv('./res/soct.csv', index=False)
                print(data, 'mfoct-d{}-a{}'.format(d,a), 'method:', 'n',
                      'train acc:', train_acc, 'test acc:', test_acc, 'gap:', mfoct.optgap)
                #print(row)

            # robust
            row = res_soct[(res_soct['instance'] == data) & (res_soct['method'] == 'rb') & (res_soct['depth'] == d) &
                           (res_soct['alpha'] == a) & (res_soct['seed'] == s)]
            if len(row):
                print(data, 'mfoct-d{}-a{}'.format(row['depth'].values[0],row['alpha'].values[0]),
                      'method', row['method'].values[0], 'train acc:', row['train_acc'].values[0], 
                      'test acc:', row['test_acc'].values[0], row['gap'].values[0])
            else:
                mfoct = miptree.maxFlowOptimalDecisionTreeClassifier(max_depth=2, alpha=a, warmstart=False,
                                                                     timelimit=timelimit, output=False)
                tick = time.time()
                mfoct.stable_fit_robust(x_train_enc, y_train, N)
                tock = time.time()
                train_time = tock - tick
                train_acc = accuracy_score(y_train, mfoct.predict(x_train_enc))
                test_acc = accuracy_score(y_test, mfoct.predict(x_test_enc))
                row = {'instance':data, 'method':'rb', 'depth':d, 'alpha':a, 'seed':s, 
                       'train_acc':train_acc, 'test_acc':test_acc, 'train_time':train_time, 'gap':mfoct.optgap}
                #res_soct = res_soct.append(row, ignore_index=True)
                res_soct.loc[len(res_soct)] = row
                res_soct.to_csv('./res/soct.csv', index=False)
                print(data, 'mfoct-d{}-a{}'.format(d,a), 'method:', 'rb',
                      'train acc:', train_acc, 'test acc:', test_acc, 'gap:', mfoct.optgap)
                #print(row)

            # cutting plane
            row = res_soct[(res_soct['instance'] == data) & (res_soct['method'] == 'cp') & (res_soct['depth'] == d) &
                           (res_soct['alpha'] == a) & (res_soct['seed'] == s)]
            if len(row):
                print(data, 'mfoct-d{}-a{}'.format(row['depth'].values[0],row['alpha'].values[0]),
                      'method', row['method'].values[0], 'train acc:', row['train_acc'].values[0], 
                      'test acc:', row['test_acc'].values[0], row['gap'].values[0])
            else:
                mfoct = miptree.maxFlowOptimalDecisionTreeClassifier(max_depth=2, alpha=a, warmstart=True,
                                                                     timelimit=timelimit, output=False)
                tick = time.time()
                mfoct.stable_fit_CP(x_train_enc, y_train, N)
                tock = time.time()
                train_time = tock - tick
                train_acc = accuracy_score(y_train, mfoct.predict(x_train_enc))
                test_acc = accuracy_score(y_test, mfoct.predict(x_test_enc))
                row = {'instance':data, 'method':'cp', 'depth':d, 'alpha':a, 'seed':s, 
                       'train_acc':train_acc, 'test_acc':test_acc, 'train_time':train_time, 'gap':mfoct.optgap}
                #res_soct = res_soct.append(row, ignore_index=True)
                res_soct.loc[len(res_soct)] = row
                res_soct.to_csv('./res/soct.csv', index=False)
                print(data, 'mfoct-d{}-a{}'.format(d,a), 'method:', 'cp',
                      'train acc:', train_acc, 'test acc:', test_acc, 'gap:', mfoct.optgap)
                #print(row)
tsoct = time.process_time()
print(f" -------------------------------------------- completing SOCT, timelimit {timelimit}, cpu {tsoct - toct}")

print("Finito!")